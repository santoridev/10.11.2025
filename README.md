### 1. Горутины и каналы

Обработка ссылок выполняется асинхронно с помощью **goroutines** и **channels**.
Каждый запрос `/check` не выполняется напрямую, а передаётся в общий канал `TaskQueue`, который выступает в роли очереди задач.
Это позволяет не блокировать основной поток HTTP-сервера и безопасно обрабатывать несколько запросов одновременно.

---

### 2. Worker Pool (пул воркеров)

Для контроля параллельной обработки используется **worker pool** — фиксированное количество воркеров (например, 5), которые берут задачи из очереди.
Каждая задача содержит собственный канал для ответа (`ResultChan`), через который результат возвращается обратно в HTTP-обработчик.
Благодаря этому пользователь получает ответ сразу после выполнения своей задачи, даже если другие запросы обрабатываются параллельно.

---

### 3. Потокобезопасность и синхронизация

Все результаты проверок сохраняются в общей структуре данных (`LinksStorage`).
Чтобы избежать состояния гонки при одновременной записи, используется `sync.Mutex`.
Это стандартный способ синхронизации данных в Go, обеспечивающий корректную работу при множестве параллельных задач.

---

### 4. Контекст и таймауты

Каждая проверка ссылки выполняется с помощью `context.WithTimeout`, что позволяет ограничить время ожидания ответа (в нашем случае — 3 секунды).
Если ссылка не отвечает за отведённое время, проверка прерывается и возвращается статус `not_available`.
Это защищает сервис от «зависаний» при обращении к недоступным ресурсам.

---

### 5. Корректная остановка сервера (graceful shutdown)

При завершении работы (например, при получении сигнала `SIGINT` или `SIGTERM`) сервер:

1. перестаёт принимать новые HTTP-запросы;
2. дожидается завершения уже активных задач;
3. закрывает пул воркеров после того, как все они закончат обработку;
4. завершает процесс после таймаута (по умолчанию 30 секунд).

Таким образом, сервис не завершает работу мгновенно, а делает это «мягко», чтобы не потерять активные проверки.

---

### 6. Поведение при новых задачах во время остановки

Если во время остановки приходят новые запросы, они могут попасть в очередь (`TaskQueue`) и будут обработаны до полного завершения работы воркеров.
Это гарантирует, что ни одна задача не будет потеряна, даже если остановка происходит в момент активной нагрузки.

